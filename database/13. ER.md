# ER : Entity Relationship

# EER : Enhance ER(ER + 슈퍼, 서브클래스 개념)

ER : 디비 스키마 디자인을 위해 만들어진 디자인 모델은 아님.
db에 데이터 모델링 랭기지로 만들어짐. 그래서 er 데이터 모델이라 함.

테이블의 한개의 형식에 때려넣는건 아닌거 같다고 해서 나온 데이터 모델. 결국 얘도 dbms 만드는거 -> db, 쿼리가 만들어짐.
근데 relational db에 짐.
데이터 모델만 살아남음. db 디자인 모델 랭기지만 살아남음.
근데 요즘엔 uml한테 또 밀리고있음.

ER : 사각형의 entity type, 타원의 attribute, attribute의 밑줄은 엔티티의 키!, 키가 두개일 수 있음.
composite attr : 하위에 attr이 더 있음
두줄 타원 : multivalued attr (RDB에선 불가능)
점선 타원 : derived attr. 쿼리를 물어본 당시에 계산을 함
마름모 : relationship type, association은 아니고 association class와 같음

엔티티타입은 명사, 릴레이션쉽 타입은 동사로 작성 왼쪽에서 오른쪽 위에서 아래로!

cardinality : n:n, 1:n .... 각 엔티티의 관계를 알려줌.

두줄, 한줄선 : participation 1개이상! 두줄 : total, 한줄 : partial

릴레이션 타입에 attr이 있을 수 있음

한 엔티티가 다른 엔티티를 supervises 할 수 있다.

엔티티 사각형 두줄 : weak entity type, composition이랑 비슷함. 이 오브젝트의 생존이 다른 엔티티에 달려있음. 부양가족을 구별하는 키는 점선 밑줄로 표현.

위크엔티티랑 릴레이션쉽 타입을 둘다 두줄로 표현함. 그리고 무조건 total임.

UML이랑 비슷함.
UML 배우고 이걸 UML로 표시한 스키마를 트랜스레이터를 통해 릴레이션이 나옴. 그걸 dbms가 받음. create table

---

엔티티타입 -> 테이블
일반 attr -> 테이블의 attr
컴포짓 attr -> 얘는 구성요소가 테이블 attr로 감
멀티플 attr -> 릴레이션으로 바뀌면서 키로 연결함.
키 attr -> 표현할땐 1개만 표현함.
카디널리티는 fk pk로 표현. 가리킴을 받는쪽이 오리지널 pk
릴레이션에 attr은 fk의 attr로 따라감

1ㄷN은 1이 pk고 n이 fk가져가고
1ㄷ1은 비교해보고, 토탈이랑 파셜로
M:N은 새로운 릴레이션을 만듬. 양쪽 pk를 fk로 받아서. 두개가 pk가 됨. 그리고 릴레이션에 attr이 있으면 추가!

위크엔티티는 테이블 새로 만들어서, 릴레이션쉽이 없어지면서 부모 키를 fk로 가져옴. 그리고 기존 키랑 합쳐서 pk를 사용함.
derived attr은 쿼리로 처리! 어플리케이션 프로그램에서 처리!

---

글로 작성할때 컴포짓은 {}로 멀티는 ()로 표현
릴레이션은 연결할때 w1(e1, d1)이렇게

---

### 서브클래스 개념을 추가한게 EER

슈퍼, 서브 클래스 개념

서브클래스가 두개이상이면 동그라미,
U가 열린곳이 슈퍼 닫힌곳 서브

UML에서
complete(두줄) vs incomplete(한줄)
disjoint(d) 부모는 자식 중 1개임 vs overlapping(o) 모든 부모가 여러개의 자식을 가질 수 있다.
개념

멀티플 상속이 되기도함. 중복된건 한쪽에서 받음.

EER을 릴레이션으로 바꾸기!

1. 멀티플 릴레이션 - 슈퍼클래스를 릴레이션 1개로 바꾸고, 서브클래스를 각각 릴레이션으로 바꿈. UML방식, 슈퍼의 pk를 자식의 fk로 가져감(토탈 파셜 디스조인트 오버래핑 다!)
2. 멀티플 릴레이션 - UML과 다르게 서브클래스만 바꿈. 토탈이고 디스조인트일 때!
3. 싱글 릴레이션 - 타입 attr을 1개만, 디스조인트면 타입컬럼 하나 놓고 작성. NULL이 많이 나옴.
4. 싱글 릴레이션 - 디스조인트도 되지만 주로 오버래핑일때, 타입 attr만큼 만들고..

컴포짓 없애고 합쳐서 pk...?

DB 디자인 -> 스키마 만드는거.
