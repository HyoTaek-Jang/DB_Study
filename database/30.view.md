뷰는 가상 테이블이다
튜플이 없음. 구조는 저장됨. 테이블에 해당되는 튜플은 저장 x

DBMS는 3단계 스키마를 가짐(피지컬 - 컨셉쳐 - 로지컬)

DBMS가 운영되는 컴퓨터에서 스토리지에 파일로 저장되는 피지컬 레벨, 파일 구조가 피지컬 스키마
모든 사용자가 접근할 수 있으면 안됨.

하나의 테이블 일부 칼럼만 보여줘야지!! 근데 이걸 보여주려고 테이블을 만든다? 근데 변경할때 동기화가 복잡함
튜플들은 오리지널 테이블 안에 저장하는게 뷰!

3 스키마 아키텍쳐에서 어플리케이션 별로 뷰를 제공함.

릴레이션 데이터베이스에선 테이블 구조!

### 뷰를 왜 쓰나?!

실제적으로 유저한테 일부 데이터를 숨겨야함. 뷰를 쓰면 쉬움
개발자 입장에서 쿼리를 만들때 조인하고 작업할때 복잡한데, 한번에 뷰에 쿼리가 심플해짐, 뷰 만드는게 귀찮더라도 ㅇㅇ
뷰를 많이 만들면 데이터 액세스를 뷰를 통해서 할 수 있음. modulatity

실제 어플리케이션은 뷰를 많이 씀.

view는 테이블! conceptual 스키마에 있는 릴레이션 테이블에 대해 뷰를 만드는 쿼리
쿼리 리절트 스키마랑 같음
튜플이 없는 테이블! 하튼 테이블이니까 쿼리가 가능함.

뷰가 쿼리를 처리할때 튜플이 없으니까 실제 처리할때 튜플이 있는 뷰가 정의된 베이스테이블로 쿼리를 변형해서 처리함.

---

### SQL Syntax

Create View Vname As <Query Sql>
Create View Vname(A1,A2,A3...) As <Query Sql>

스냅샷 개념인가? 아닌듯
쿼리를 단축어로 만든 개념인가? 뷰는 베이스테이블에 대한 쿼리로 바뀌니까!

뷰의 장점
계속 테이블이 변경될때 항상 동기화가 된다?!

뷰는 따른 쿼리에도 사용이 됨.

비슷하게 테이블을 만들 수 있는데 이러면 진짜 튜플이 있는 테이블임.

쿼리를 간단하게 만들어주는!

drop view는 연관 관계를 파악해야지 가능함. 내 위에 뭔가 있으면 드랍 못함

---

# view modify

뷰는 테이블로 처리하고 쿼리에 대한 처리는 베이스 테이블에 대한 쿼리로 바껴서 처리됨

모디피케이션은 애매함.
해결책

1. trigger로 문제가 났을때 처리되게 한다. 트리거 자동 검증이 안됨
2. 에러가 안나게 시스템이 처리.

---

# 트리거로 모디파이 하기!

INSTEAD OF 라는 트리거 키워드를 사용!

만약 instead of delete on ~~ 하면 딜리트 대신 ~부분 해라~ 이거지
Old.cName은 딜리트 되는 cName

instead of update of cName on cSaccept

트리거로 베이스 릴레이션을 수정해야함.

```sql
create view CSEE as
select sID, cName, major
from Apply
where major = 'CS' or major = 'EE';
```

```sql
create trigger CSEEinsert
instead of insert on CSEE
for each row
when New.major = 'CS' or New.major = 'EE'
begin
    insert into Apply values (New.sID, New.cName, New.major, null);
end;
```

aggregation(min, max, avg...)가 쓰이면 무조건 트리거고 뭐고 모디파이 안됨
distinct projection 또한 안됨.
self nested, self subquery 된 경우도 안됨.\

before 쓰면 결국엔 그 작업을 해야해서 안됨!! 인스티드 오브!!

업데이트는 어트리뷰트마다 트리거가 필요함

---

유저가 트리거를 만들지 않고 dbms를 알아서 뷰 모디파이를 처리하는!!
근데 상당히 많은 제약사항이 있음.

업데이트가 되는 기본조건

1. 뷰가 정의된 테이블이 싱글 테이블. no distinct
2. 뷰에 포함되지 않는 attr이 null이나 디폴트가 있어야함.
3. 셀프 서브쿼리 노노 셀프 레퍼런싱
4. 그룹 바이, 에그리제이션 노노

오토매틱 뷰 모디피케이션은 MYSQL만 가능함.

when처럼 체크 불가.

뷰를 만들때 with check option 이 있음.
모디파이할때 뷰 테이블에 맞게 들어오는지 체크. 아니면 에러

트리거로 안되는건 오토매틱으로도 안됨

웨어문 서브쿼리하면 딜리트는 잘되는데 인서트는 베이스 테이블에만 들어감.
이거도 쳌 옵션하면 인서트 안됨

쳌 옵션에서는 모디파이하면 그거에 대한 결과가 뷰에 반영이 안되면 에러임!

조인된 뷰에는 딜리트가 안됨.

---

# MATERIALIZED VIEW

뷰에 데이터가 저장되있는거
쿼리 퍼포먼스를 향상시킴.
기존에 쓰던건 virtual view

뷰가 크면 머태리얼라이즈함.
매번 계산해야하니까 시간이 오래걸린거 같아서, 머태리얼라이즈 뷰로 계산의 시간을 줄인다
데이터가 뷰랑 릴레이션에 저장되있음. 서로 연결되있음. 싱크를 맞추는 오버헤드가 있음.

create Materialized view CA-CS As ~~

데이터가 저장되있어서 베이스 릴레이션으로 컨버전 되지 않음.

업데이트 될 때 베이스 테이블이랑 싱크를 맞춰야함. 그래서 베이스 테이블 모디파이해야함.

언제 하느냐!

1. 데이터의 사이즈가 크고
2. 뷰가 complex하다
3. 쿼리가 많다
4. 모디피케이션이 작다.

### automatic query rewriting

알아서 쿼리를 바꿈. 리롸이팅. 머태리얼라이즈드 뷰로 ㅇㅇ...!

---

# Authorization

유저들한테 디비를 제한적으로 액세스하게!
유저마다 테이블에 대한 오퍼레이션을 제한!

1. 유저별로 볼 수 있는 것만 보이게!
2. 데이터의 modify를 막으려고!

심플하게 유저가 테이블에 대해 특정 오퍼레이션을 실행할 수 있는 프리빌리지를 갖는거

뷰에대해 오퍼레이션도 제한 할 수 있음.
뷰에 대해서도 프리빌리지!

일단 릴레이션 만든 사람이 오너임
그 오너가 프리빌리지를 나누는거(grant)!
프리빌리지 : 딜리트 업데이트 셀렉트

Grant privs~ on R to users [with grant option]
grant option있으면 다른 애한테 부여가능

Revoke privs on R from users [cascade | restrict]
리스트릭트는 받은 놈만 뺏는거
캐스캐이트는 아래 모든거 전부다!

멀티플로 받았으면 한 쪽만 사라짐.

각 유저가 일부만 건들이는게 일반적임.
