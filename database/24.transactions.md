# 트랜잭션이 나온 배경

dbms는 여러 앱, 유저가 동시에 접근하여 요구함. concurrent함.
컨커런씨를 잘 유지해도 system failures가 일어날 수 있음. 근데 중간 쿼리가 제대로 안끝나면?

그래서 트랜잭션이 나옴 위 케이스를 해결하려고

---

업데이트 명령을 내리면 메모리로 읽어봐서 특정 튜플의 수치를 바꾸고, 가져다 놓는거임. 일종의 버퍼처럼 ㅇㅇ!

get(디비-> 메모리), modify(수정), put(메모리->디비) 명령!

타이밍이 안맞으면 예상한 결과가 다르게 나올 수 있음.

컨커런시를 컨트롤할 메커니즘이 없어서 트랜잭션이 나옴

## concurrent access

1. attribute level inconsistency
2. tutple level inconsistency
3. table level inconsistency
4. multi-statement inconsistency

이런 문제가 발생하지 않고 컨커런트를 유지하면서 dbms가 여러 스테이트먼트가 dbms는 최대한 섞어서 처리하지만 마치 각각 독립된거처럼 처리한 결과가 나오게 하는게 목점임. 컨커런시를 유지하면서.
섞어서 처리해도 결과가 올바르게 나오게!

## system failures

데이터를 디비에 올리다가 크러쉬가 남.
이래도 모든게 잘 전송되거나 하나도 다 리젝트하거나 해야함. 극과 극으로
그래서 트렉잭션이 필요함.

트랜잭션은 1, 1개 이상 SQL을 하나의 단위로 묶은 유닛

이걸 묶어서 각 트랜잭션은 구성하는 시퀄스테이트먼트들을 dbms가 다른 트랙잭션을 구성하는 애랑 섞어서 컨커런트하게 처리하지만 트랜잭션 단위들이 마치 결과는 독립적인..? 뭐라는거야 발음 진짜 ㅏㅇ오

시스템 페일되면 트랙잭션은 아예 처음으로 되돌리거나 완전히 반영되거나 ㅇㅇ!

---

### sql standard

첫번째 sql statement는 그냥 자동으로 트랜잭션이 시작한다.
commit은 커런트 트랜잭션을 끝내고 새로운게 시작되는거
그러다 세션이 엔드가 나면 트랜잭션도 끝남.
autocommit 각 statement를 트랙잭션으로 정의하는거
